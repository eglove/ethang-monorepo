---
import "highlight.js/styles/night-owl.css";
import BlogLayout from "../../layouts/BlogLayout.astro";
import CodeBlock from "../../components/CodeBlock.astro";
import reactSimpleComplex from "../../images/react-simple-complex.png";
import BlogWidgets from "../../components/BlogWidgets.astro";
---

<BlogLayout
  title="React Performance: Why Memoization Isnâ€™t Always the Silver Bullet"
  description="Unlock better React performance! Discover why React.memo and deep equality checks often fall short, and learn a more effective strategy for optimizing re-renders by syncing your UI with external data stores. Improve your React application's speed and maintainability."
>
  <h1>
    React Performance: Why Memoization Isn&rsquo;t Always the Silver Bullet
  </h1>

  <ul>
    <li>
      <a href="https://react-performance.hello-a8f.workers.dev/" target="_blank"
        >This app</a
      > acts as a visual representation of the topics discussed.
    </li>
    <li>
      The code is <a
        href="https://github.com/eglove/ethang-monorepo/tree/master/apps/react-performance"
        target="_blank">on GitHub here</a
      >
    </li>
  </ul>

  <BlogWidgets image={{src: reactSimpleComplex, alt: "React performance optimization: a visual contrast between inefficient prop drilling and efficient global state management."}} />

  <p>
    As React applications grow in complexity, managing performance becomes a
    critical concern. One of the first techniques developers often reach for to
    combat unnecessary re-renders is component memoization, using tools like <code
      >React.memo</code
    >, <code>useMemo</code>, and <code>useCallback</code>. While these are
    invaluable, focusing solely on memoization can sometimes feel like an uphill
    battle, addressing symptoms rather than the root cause.
  </p>

  <p>
    The truth is, simply wrapping components in <code>React.memo</code> often doesn&rsquo;t
    solve the core problem of widespread re-renders. Instead, a more effective strategy
    involves rethinking <em>how</em> our React UI syncs with its underlying data
    and logic, focusing precisely on <em>when</em> and <em>what</em> data needs to
    be synchronized.
  </p>

  <h2 id="re-render-why">
    The Re-render Conundrum: Understanding the &ldquo;Why&rdquo;
  </h2>

  <p>
    In React, components re-render when their state or props change. This
    re-rendering process is generally fast, and React&rsquo;s reconciliation
    algorithm efficiently updates only the necessary parts of the DOM. However,
    frequent and widespread re-renders, especially in large component trees, can
    still lead to noticeable performance bottlenecks.
  </p>

  <p>
    Consider a scenario where you have a deeply nested component tree, and a
    piece of data at the very top of the tree changes. If this data is passed
    down through props to many children, even if only one child <em>actually</em
    > uses the changed data, all intermediate components might re-render. This is
    where <code>React.memo</code> comes in, allowing a component to skip re-rendering
    if its props haven&rsquo;t changed.
  </p>

  <p>
    Let&rsquo;s look at a simplified example, illustrating traditional prop
    drilling:
  </p>

  <CodeBlock
    code={`
// Traditional Prop Drilling Example
const TraditionalPLCell = React.memo(({ position, price }) => {
  // ... component logic ...
  // ... render ...
});

const TraditionalTableRow = React.memo(({ position, prices }) => {
  const price = prices[position.symbol]; // Price is looked up from passed \`prices\` object
  return (
    <tr>
      {/* ... other cells ... */}
      <TraditionalPLCell position={position} price={price} />
    </tr>
  );
});

const TraditionalTable = ({ positions, prices }) => {
  return (
    <div>
      {positions.map(position => (
        <TraditionalTableRow key={position.symbol} position={position} prices={prices} />
      ))}
    </div>
  );
};`}
  />

  <p>
    In this structure, if <code>prices</code> (an object containing many symbol prices)
    updates in <code>TraditionalTable</code>, even if <code>React.memo</code> is
    applied to <code>TraditionalTableRow</code>, the <code>prices</code> object itself
    is a new reference on each update. This causes <code
      >TraditionalTableRow</code
    > to re-render, and in turn, <code>TraditionalPLCell</code> also re-renders,
    even if <code>position</code> hasn&rsquo;t changed. Each update to <em
      >any</em
    > price can potentially trigger re-renders across the entire table.
  </p>

  <p>
    This illustrates a common pitfall: <code>React.memo</code> performs a shallow
    comparison of props. If a prop is an object or array, and its reference changes
    (even if its <em>contents</em> are the same), <code>React.memo</code> will consider
    it a change and trigger a re-render.
  </p>

  <h2 id="real-culprit-data-flow">The Real Culprit: Uncontrolled Data Flow</h2>

  <p>
    The issue isn&rsquo;t memoization itself but rather the underlying data
    flow. When we &ldquo;prop drill&rdquo; all data down from a parent
    component, any change in that parent&rsquo;s state (which then flows as new
    props to children) can invalidate memoization. It&rsquo;s like trying to
    patch individual leaks in a hose when the entire faucet is gushing.
  </p>

  <p>
    This is basically putting all data into a React component and then going in
    behind it trying to memoize, it doesn&rsquo;t work. It suggests a reactive,
    top-down data flow that makes effective memoization challenging. If a parent
    component holds all the data and passes it down, re-renders at the top will
    naturally ripple downwards, bypassing many memoization efforts.
  </p>

  <h2 id="superior-approach-external-stores">
    The Superior Approach: Syncing UI with External Stores
  </h2>

  <p>
    A more robust and scalable solution involves decoupling your
    component&rsquo;s needs from its parent&rsquo;s state, and instead, directly
    connecting components to external, optimized data stores. This allows
    components to &ldquo;subscribe&rdquo; to <em>only</em> the specific pieces of
    data they need, triggering re-renders only when that particular data changes.
  </p>

  <p>This approach focuses on two key principles:</p>

  <ul>
    <li>
      <strong>Points of Sync</strong>: Identifying the precise locations where a
      component needs to read data from an external source.
    </li>
    <li>
      <strong>Exactly What to Sync</strong>: Ensuring that only the <em
        >minimal necessary</em
      > data is fetched and listened to.
    </li>
  </ul>

  <p>
    The &ldquo;Optimized ID Lookup&rdquo; pattern demonstrated by the following
    code beautifully illustrates this concept using <code>React Query</code> (which
    acts as an external cache/store for data):
  </p>

  <CodeBlock
    code={`
// Optimized ID Lookup Example (using React Query)
const OptimizedPLCell = React.memo(({ symbol, entryPrice, quantity }) => {
  // Directly fetch price for this specific symbol using useQuery
  const { data: price, isLoading, isError } = useQuery({
    queryKey: ['price', symbol], // Unique key for this price
    queryFn: () => fetchPriceQuery(symbol), // Function to get the price
  });

  // Simulate real-time updates by manually setting query data
  useEffect(() => {
    const interval = setInterval(() => {
      // Direct update to the React Query cache for this specific price
      queryClient.setQueryData(['price', symbol], mockPrices[symbol]);
    }, 200);
    return () => clearInterval(interval);
  }, [symbol]);

  if (isLoading || isError || price === undefined) {
      // Handle loading/error states
      return null;
  }

  const pnl = calculatePnL(price, entryPrice, quantity);
  return (
    <td>{pnl.toFixed(2)}</td>
  );
});

const OptimizedCurrentPriceCell = React.memo(({ symbol }) => {
  // Similar direct fetching for the current price
  const { data: price } = useQuery({
    queryKey: ['price', symbol],
    queryFn: () => fetchPriceQuery(symbol),
  });
  // ... useEffect for updates ...
  return (
    <td>{price ? price.toFixed(2) : 'N/A'}</td>
  );
});

const OptimizedTableRow = React.memo(({ position }) => {
  return (
    <tr>
      {/* ... other static cells ... */}
      <OptimizedCurrentPriceCell symbol={position.symbol} />
      <OptimizedPLCell
        symbol={position.symbol}
        entryPrice={position.entryPrice}
        quantity={position.quantity}
      />
    </tr>
  );
});`}
  />

  <p>Here&rsquo;s how this approach shines:</p>

  <ul>
    <li>
      <strong>Decoupled Components</strong>: <code>OptimizedPLCell</code> and <code
        >OptimizedCurrentPriceCell</code
      > don&rsquo;t receive <code>price</code> as a prop from their parent. Instead,
      they directly <em>query</em> for the price they need using <code
        >symbol</code
      > as an ID.
    </li>
    <li>
      <strong>Targeted Re-renders</strong>: When <code
        >queryClient.setQueryData(['price', symbol], ...)</code
      > is called, React Query intelligently updates only the components that are
      subscribed to <em>that specific query key</em> (<code
        >['price', symbol]</code
      >). This means if the &lsquo;BTC&rsquo; price changes, only the <code
        >OptimizedPLCell</code
      > and <code>OptimizedCurrentPriceCell</code> for &lsquo;BTC&rsquo; re-render,
      not the entire row or table.
      <br /><br />
      A key advantage of React Query is its ability to handle selectors. You can
      safely reuse the same <code>useQuery</code> hook across multiple components
      for the same data (e.g., the price of 'BTC'). React Query will ensure that
      the underlying data fetching is only performed once. Furthermore, you can use
      <a
        href="https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations"
        target="_blank"
        rel="noopener noreferrer">selectors</a
      > within <code>useQuery</code> to extract only the specific slice of data a
      component needs from a larger query result. This means components only re-render
      when the *exact piece of data they depend on* changes, not just when the broader
      query result updates.
    </li>
    <li>
      <strong>Simplified Memoization</strong>: <code>OptimizedTableRow</code> can
      still be memoized effectively because its <code>position</code> prop is stable.
      The dynamic data (price) is handled by its children&rsquo;s independent subscriptions.
    </li>
  </ul>

  <p>
    This paradigm shift moves away from passing data down and hoping memoization
    catches unnecessary re-renders, towards a model where components
    declaratively state what data they need, and efficient caching/state
    management libraries deliver exactly that.
  </p>

  <h2 id="deep-equality-argument">
    Addressing the &ldquo;Deep Equality&rdquo; Argument
  </h2>

  <p>
    A common counterpoint to the limitations of <code>React.memo</code>&rsquo;s
    shallow comparison is the ability to provide a custom comparison function,
    often a deep equality check, as its second argument:
  </p>

  <CodeBlock
    code={`
import React from 'react';
import isEqual from 'lodash.isequal'; // Or a custom deep comparison utility

const MyMemoizedComponent = React.memo((props) => {
  // ... component rendering ...
}, isEqual); // Using deep equality for prop comparison`}
  />

  <p>
    While this technique <em>can</em> prevent re-renders when prop references change
    but their underlying contents remain the same, it introduces its own set of significant
    considerations:
  </p>

  <ol>
    <li>
      <strong>Performance Cost of Deep Equality</strong>: Performing a deep
      comparison can be computationally expensive, especially for large, complex
      objects or arrays, or in scenarios with very frequent updates. The
      overhead of traversing and comparing potentially deep data structures
      might, in certain cases, be more costly than the re-render it aims to
      prevent. It&rsquo;s a trade-off where the &ldquo;fix&rdquo; itself
      consumes valuable resources.
    </li>
    <li>
      <strong>Hiding Underlying Issues</strong>: Relying extensively on deep
      equality comparisons can inadvertently mask suboptimal data flow patterns.
      If components frequently receive new references to large data structures
      that necessitate deep comparison, it often indicates that they are
      receiving more data than they truly need, or that state updates are too
      broad and affect many components unnecessarily. Deep equality becomes a
      reactive measure to an already inefficient proactive design.
    </li>
    <li>
      <strong>Still Reactive, Not Proactive</strong>: Even with a deep equality
      check, the component is still <em>reacting</em> to changes in its entire prop
      structure. It doesn&rsquo;t inherently know <em>which specific part</em> of
      a deeply nested prop changed, only that <em>something</em> is different. This
      contrasts sharply with an external store approach, where a component explicitly
      subscribes to <em>only</em> the precise, granular data it needs, triggering
      updates solely when that specific piece of data changes.
    </li>
    <li>
      <strong>Increased Complexity and Debugging</strong>: Incorporating custom
      comparison functions, particularly deep ones, can increase the overall
      complexity of your component logic. Debugging re-render issues can become
      more challenging, as you need to reason not only about React&rsquo;s
      reconciliation but also about the intricacies of your custom comparison
      logic. This can divert development effort towards optimizing the
      comparison itself rather than streamlining the core data management.
    </li>
  </ol>

  <p>
    In essence, while deep equality is a valid tool in the memoization arsenal,
    it often serves as a &ldquo;patch&rdquo; applied on top of a data flow that
    might benefit more from fundamental architectural adjustments. External
    state management solutions inherently provide mechanisms for fine-grained
    subscriptions and notifications. They empower components to
    &ldquo;pull&rdquo; only the exact data they require, and the state
    management layer efficiently ensures that components are only
    notified&mdash;and thus re-render&mdash;when <em>those specific pieces</em> of
    data actually change. This paradigm shifts the burden of granular updates from
    complex prop comparisons to a dedicated state management layer, leading to cleaner
    code, improved predictability, and often superior performance for large-scale
    applications.
  </p>

  <h2 id="client-side-sorting">
    Client-Side Sorting and Filtering: When to Consider It
  </h2>

  <p>
    When dealing with data display in a React application, sorting and filtering
    are common requirements. Ideally, these operations should be handled on the
    server-side. Server-side sorting and filtering dramatically reduce the
    amount of data transferred to the client, lessen the computational burden on
    the user's device, and ensure consistent results across all users. For large
    datasets, server-side processing is almost always the superior choice for
    performance and scalability.
  </p>

  <p>
    However, server-side capabilities aren't always available, or the dataset
    might be small enough that the overhead of a network request outweighs the
    benefit. In such scenarios, performing sorting and filtering on the
    client-side becomes a pragmatic necessity. This is where the power of a
    client-side cache, like the one provided by React Query, can be leveraged
    effectively.
  </p>

  <p>
    Instead of relying on props passed down from a parent component that might
    contain a heavily processed and sorted array, individual components or a
    dedicated sorting logic can directly access the cached, normalized data. For
    instance, if you need to sort a list of positions by their P&L (Profit &
    Loss), which is a derived value dependent on the current price, your sorting
    function can look up the live price from React Query's cache:
  </p>

  <CodeBlock
    code={`
// Assuming \`queryClient\` is available from React Query context or imported
// And \`positions\` is an array of objects like { symbol: 'BTC', entryPrice: 30000, quantity: 0.5 }

const sortByPnL = (positions, queryClient) => {
  return [...positions].sort((a, b) => {
    // Get current price for position 'a' from React Query's cache
    const priceA = queryClient.getQueryData(['price', a.symbol]);
    // Get current price for position 'b' from React Query's cache
    const priceB = queryClient.getQueryData(['price', b.symbol]);

    // Handle cases where price might not be available yet (e.g., loading)
    if (priceA === undefined || priceB === undefined) return 0; // Or handle as needed

    const pnlA = (priceA - a.entryPrice) * a.quantity;
    const pnlB = (priceB - b.entryPrice) * b.quantity;

    return pnlA - pnlB; // Sort ascending by P&L
  });
};

// Usage within a component:
// const sortedPositions = useMemo(() => sortByPnL(positions, queryClient), [positions, queryClient]);`}
  />

  <h3>Performance Trade-offs of Client-Side Sorting</h3>
  <ul>
    <li>
      <strong>Pros:</strong>
      <ul>
        <li>
          <strong>Instant UI Feedback:</strong> Sorting and filtering happen immediately
          without network latency, leading to a snappier user experience.
        </li>
        <li>
          <strong>Reduced Server Load:</strong> For small to medium datasets, offloading
          these operations to the client reduces the burden on your backend server.
        </li>
        <li>
          <strong>Offline Capabilities:</strong> Once data is cached, limited sorting
          and filtering might be possible even without an active internet connection.
        </li>
      </ul>
    </li>
    <li>
      <strong>Cons:</strong>
      <ul>
        <li>
          <strong>Increased Client-Side Processing:</strong> The browser's main thread
          can become bogged down if sorting/filtering large datasets or if the comparison
          logic is computationally intensive.
        </li>
        <li>
          <strong>Larger Initial Data Fetches:</strong> To enable client-side operations,
          the initial data payload from the server might need to be larger, as all
          relevant data must be present on the client.
        </li>
        <li>
          <strong>Potential for Complex Logic:</strong> Implementing robust sorting
          and filtering for all edge cases (e.g., locale-specific sorting, complex
          text searches) on the client can lead to more intricate and bug-prone code.
        </li>
        <li>
          <strong>Memory Consumption:</strong> Holding large datasets in memory on
          the client side can consume significant resources, especially on lower-end
          devices.
        </li>
      </ul>
    </li>
  </ul>

  <p>
    Despite these trade-offs, client-side sorting and filtering, particularly
    when integrated with a robust caching mechanism like React Query, can be the
    right decision in specific contexts. For dashboards displaying live,
    frequently updating data where quick visual manipulation is key, or for
    applications dealing with relatively small, static datasets, the benefits of
    immediate responsiveness often outweigh the costs. The key is to be mindful
    of the dataset size and the complexity of the operations, and to always
    prioritize server-side solutions when dealing with vast amounts of data or
    when scalability is paramount.
  </p>

  <h2 id="conclusion">Conclusion</h2>

  <p>
    While <code>React.memo</code>, <code>useMemo</code>, and <code
      >useCallback</code
    > are essential tools in the React performance toolkit, they are most effective
    when used strategically. Relying on them as a primary fix for widespread re-renders,
    especially in the presence of extensive prop drilling, often proves futile. And
    while custom deep equality comparisons offer a solution, they introduce their
    own set of performance and complexity overheads that can negate their benefits.
  </p>

  <p>
    The key to truly optimizing React performance lies in a more fundamental
    understanding of data flow. By focusing on explicit points of
    synchronization with external data stores (like React Query, Redux, Zustand,
    or even a simple global state object) and fetching/subscribing to only the
    exact data required by a component, we can achieve far more precise and
    efficient re-rendering patterns. This approach allows components to remain
    &ldquo;pure&rdquo; and independent, leading to more predictable performance
    and a more maintainable codebase.
  </p>

  <p>
    So, next time you face re-render woes, think beyond memoization&mdash;even
    with deep equality. Consider your data architecture and how your components
    interact with your application&rsquo;s state. Sync smart, not hard!
  </p>
</BlogLayout>
