---
import BlogLayout from "../../layouts/BlogLayout.astro";
import CodeBlock from "../../components/CodeBlock.astro";
import "highlight.js/styles/night-owl.css";
import WordCount from "../../components/WordCount.astro";
import LocalImage from "../../components/LocalImage.astro";
import featuredImage from "../../images/chaotic-state-to-simplicity.png";
---

<BlogLayout
  title="Escaping Hook Hell"
  description="Unlock simpler, more performant React state management. Learn how to leverage JavaScript's hybrid nature and external class-based stores with useSyncExternalStore to reduce boilerplate, improve testability, and gain precise control over UI updates, moving beyond complex, paradigm-driven solutions."
>
  <h1>Escaping Hook Hell: Pragmatic State Management for Hybrid JavaScript</h1>
  <WordCount />

  <LocalImage
    src={featuredImage}
    alt="An abstract illustration depicting a messy, tangled web of dark lines and nodes transforming into a clear, smooth, bright path leading to a simple, streamlined structure, symbolizing the simplification of complex code."
  />

  <ul>
    <li>
      <a href="#lure-of-universe"
        >The Lure of the "Universe" and the Cost of Complexity</a
      >
    </li>
    <li>
      <a href="#pragmatic-power"
        >The Pragmatic Power of External Stores with `useSyncExternalStore`</a
      >
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>

  <p>
    State management in React applications is a journey often fraught with
    decisions. We're constantly seeking the "best" way to manage our data,
    leading us to explore a myriad of libraries and patterns. While many promise
    to simplify complexity, it's crucial to evaluate whether the chosen solution
    truly streamlines development or inadvertently introduces its own set of
    hurdles and conceptual overhead.
  </p>

  <h2 id="lure-of-universe">
    The Lure of the "Universe" and the Cost of Complexity
  </h2>

  <p>
    A common temptation in front-end development is to adopt libraries that
    introduce a comprehensive "universe" of functional programming paradigms.
    While the principles of functional programming are powerful, pushing a
    language like JavaScript—which is inherently multi-paradigm, much like Go or
    Rust—into a strictly functional mold can sometimes lead to unforeseen
    complexity and boilerplate. JavaScript's hybrid nature is one of its
    greatest strengths; it seamlessly supports elements of both functional
    programming (e.g., first-class functions, closures, higher-order functions)
    and object-oriented programming (e.g., classes, prototypes, inheritance).
    Languages like Go and Rust also exhibit this flexibility, allowing
    developers to choose the most appropriate paradigm or a blend of them for a
    given problem. This flexibility means that trying to rigidly enforce a pure
    functional or pure object-oriented style across an entire JavaScript
    codebase can often feel forced. Instead of leveraging the language's
    inherent pragmatism to solve problems directly, developers might find
    themselves introducing complex abstractions, extensive utility functions, or
    deeply nested structures purely to adhere to a specific paradigm's
    conventions. This can lead to increased boilerplate, reduce readability for
    developers not steeped in that particular paradigm's idioms, and ultimately
    make the code harder to debug and maintain, as the solution prioritizes
    adherence to a philosophical approach over direct, understandable
    problem-solving.
  </p>

  <p>
    Consider the example of integrating external reactive libraries like <strong
      >RxJS</strong
    > directly into React components. You might encounter patterns involving <code
      >useRef</code
    > to hold instances of <code>BehaviorSubject</code> and <code
      >Observable</code
    >, complete with conditional initialization and <code>as const</code> assertions
    to ensure type safety. While technically functional, this approach often feels
    like an intricate dance to make an external, mutable data source fit into React's
    predominantly immutable, hook-based environment. The very act of wrapping these
    constructs within React's lifecycle methods and dependencies can obscure the
    core problem being solved.
  </p>

  <CodeBlock
    code={`
import { useRef, useEffect } from 'react';
import { BehaviorSubject, Observable } from 'rxjs';
import { debounceTime } from 'rxjs/operators';

const useBehaviorSubject = (initialData) => {
  // Use useRef to hold the mutable BehaviorSubject and Observable instances
  // This pattern attempts to prevent re-creation on every render
  const subjectRef = useRef(null);
  const observableRef = useRef(null);

  if (!subjectRef.current) {
    subjectRef.current = new BehaviorSubject(initialData);
  }
  if (!observableRef.current) {
    observableRef.current = subjectRef.current.asObservable();
  }

  return [subjectRef.current, observableRef.current];
};

const MyComponent = () => {
  const [dataSubject, dataObservable] = useBehaviorSubject({ name: 'initial' });

  useEffect(() => {
    const subscription = dataObservable.pipe(
      debounceTime(300)
    ).subscribe(value => {
      console.log('Debounced data:', value);
      // In a real app, this might trigger a React state update, adding more complexity
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [dataObservable]); // Dependency array may need the observable ref

  const updateData = () => {
    dataSubject.next({ name: 'updated' + Math.random() });
  };

  return (
    <div>
      <p>Data: {dataSubject.getValue().name}</p>
      <button onClick={updateData}>Update Data</button>
    </div>
  );
};`}
  />
  <p>
    The allure of "magic operators" for tasks like debouncing, throttling,
    cancellation, or error handling is strong. RxJS operators are indeed
    powerful for composing complex asynchronous flows. However, when these
    operators necessitate a significant amount of setup within <code
      >useEffect</code
    > hooks, managing subscriptions, and carefully orchestrating <code
      >useRef</code
    > instances, the perceived reduction in complexity at the "consumer level" can
    be offset by increased boilerplate and cognitive load at the implementation level.
    This is particularly true when similar functionalities could be achieved with
    simpler, more direct JavaScript utilities or established patterns designed without
    the need for a full paradigm shift. Indeed, many of these "complex asynchronous
    flows" can be managed effectively with plain logic implemented directly within
    classes, leveraging standard JavaScript features and perhaps lightweight utility
    libraries (like Lodash for <code>debounce</code> or <code>throttle</code>)
    without the need for specialized piping or a comprehensive reactive
    framework.
  </p>

  <p>
    The code example above also illustrates a deeper problem: the act of
    instantiating a <code>BehaviorSubject</code> (or any class intended as a long-lived
    state container) directly within a <code>useRef</code> inside a custom hook.
    This pattern often stems from a pervasive mindset—that all state and logic must
    be managed <em>within</em> React's component lifecycle. This leads to a common
    misconception about what constitutes a "stable reference" in a JavaScript application.
  </p>

  <p>
    Developers sometimes assume that to ensure an object (like a class instance
    managing application state) persists and remains consistent across component
    re-renders, it <em>must</em> be instantiated within a React hook, such as <code
      >useRef</code
    > or even <code>useState</code> with a lazy initializer (<code
      >useState(() => new MyClass())</code
    >). However, this is a misconception when dealing with truly external state.
    A "stable reference" simply means a consistent pointer to the <em
      >same object instance</em
    > throughout the application's runtime, regardless of how many times a React
    component renders.
  </p>

  <p>
    For an external store, this stability is naturally achieved by instantiating
    the class once, outside of any React component or hook. For example, you can
    create a single instance of your <code>Store</code> class directly within an
    ES module file:
  </p>

  <CodeBlock
    code={`
class Store { /* ... implementation ... */ }
export const myGlobalStore = new Store(); // Instantiated once when the module loads`}
  />

  <p>
    This <code>myGlobalStore</code> variable then holds a truly stable reference.
    Wherever it's imported in your application, you'll always get the exact same
    object instance. If you need multiple, distinct instances of your store, you
    can simply declare them as separate exports in the same module or different modules:
  </p>

  <CodeBlock
    code={`
class Store { /* ... implementation ... */ }
export const myFeature1Store = new Store();
export const myFeature2Store = new Store();`}
  />

  <p>
    This approach completely removes the need for "ref shenanigans" or using <code
      >useState</code
    > for instantiation, as the class is already instantiated once and available
    for direct import. <code>useSyncExternalStore</code> then seamlessly integrates
    with this already-stable external instance. It simply calls its <code
      >getSnapshot</code
    > (or <code>getState</code>) function to retrieve the current state and its <code
      >subscribe</code
    > function to listen for updates, all without requiring complex <code
      >useRef</code
    > "hacks" or intricate <code>useEffect</code> dependency arrays to manage the
    external store's lifecycle within React. By embracing this separation, we avoid
    scattering state management logic across numerous component-specific hooks, context
    providers, and reducers. This fragmentation, combined with a deep reliance on
    <code>useEffect</code> and its often-tricky dependency arrays, frequently leads
    to subtle bugs, unpredictable re-renders, and significant performance bottlenecks.
  </p>

  <h2 id="pragmatic-power">
    The Pragmatic Power of External Stores with `useSyncExternalStore`
  </h2>

  <p>
    A more pragmatic and often simpler philosophy is to intentionally keep
    complex application logic and external state *outside* of React components
    and hooks, only connecting to the UI when necessary. This involves creating
    "external stores"—often implemented as simple class-based entities—that are
    responsible for managing specific domains of your application state and
    their associated business logic.
  </p>

  <p>
    These stores are independent of React's component lifecycle. They can handle
    asynchronous operations, manage complex form states, pagination, modal
    visibility, and even integrate seamlessly with other data management
    libraries. They encapsulate all the "how" (how data is fetched, how search
    is debounced, how pagination works) so that your React components can focus
    purely on the "what"—rendering the UI based on the store's exposed state and
    delegating actions back to the store.
  </p>

  <p>
    Let's look at the basic structure of such a state management store class:
  </p>

  <CodeBlock
    code={`
import produce from 'immer';
import debounce from 'lodash/debounce';

const DEFAULT_STATE = {
  data: [],
  isLoading: false,
  error: null,
  searchTerm: '',
  currentPage: 1,
  totalPages: 1,
  isCreateModalOpen: false,
  isEditModalOpen: false,
};

class Store {
  constructor() {
    this.state = DEFAULT_STATE;
    this.subscribers = new Set();
    this.debouncedSearch = debounce(this._performSearch, 500);
  }

  // Method required by useSyncExternalStore to get the current state snapshot
  getSnapshot() {
    return this.state;
  }

  // Method required by useSyncExternalStore to subscribe to state changes
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  // Internal method to notify all subscribed components of state changes
  _notifySubscribers() {
    this.subscribers.forEach(callback => callback());
  }

  // Generic update method using Immer for immutable state changes
  update(updater, shouldNotify = true) {
    this.state = produce(this.state, draft => {
      updater(draft);
    });
    if (shouldNotify) {
      this._notifySubscribers();
    }
  }

  // --- Example methods for specific business logic ---

  async fetchData(userId) {
    this.update(draft => { draft.isLoading = true; draft.error = null; });
    try {
      const response = await new Promise(resolve => setTimeout(() => {
        resolve({
          data: [{ id: 1, title: 'Item A' }, { id: 2, title: 'Item B' }],
          pagination: { currentPage: 1, totalPages: 1 }
        });
      }, 500));

      this.update(draft => {
        draft.data = response.data;
        draft.currentPage = response.pagination.currentPage;
        draft.totalPages = response.pagination.totalPages;
        draft.isLoading = false;
      });
    } catch (error) {
      this.update(draft => { draft.error = error.message; draft.isLoading = false; });
    }
  }

  // Example of a method returning query options for React Query
  // This centralizes query logic within the store
  getAllDataQueryOptions(userId) {
    const { searchTerm, currentPage } = this.state;
    return {
      queryKey: ['data', userId, searchTerm, currentPage],
      queryFn: async () => {
        const response = await new Promise(resolve => setTimeout(() => {
          resolve({
            data: [{ id: 1, title: 'Item A' }, { id: 2, title: 'Item B' }],
            pagination: { currentPage: 1, totalPages: 1 }
          });
        }, 500));

        this.update(draft => {
          draft.data = response.data;
          draft.currentPage = response.pagination.currentPage;
          draft.totalPages = response.pagination.totalPages;
        }, false); // Don't notify immediately, React Query will handle re-render
        return response.data;
      },
      staleTime: 1000 * 60 * 5, // 5 minutes
    };
  }

  // --- Modal Management ---
  openCreateModal() {
    this.update(draft => { draft.isCreateModalOpen = true; });
  }

  closeCreateModal() {
    this.update(draft => { draft.isCreateModalOpen = false; });
  }

  openEditModal() {
    this.update(draft => { draft.isEditModalOpen = true; });
  }

  closeEditModal() {
    this.update(draft => { draft.isEditModalOpen = false; });
  }

  // --- Debounced Search ---
  setSearchTerm(term) {
    this.update(draft => { draft.searchTerm = term; });
    this.debouncedSearch(term);
  }

  _performSearch = async (term) => {
    this.update(draft => { draft.isLoading = true; });
    console.log('Performing debounced search for:', term);
    await new Promise(resolve => setTimeout(resolve, 500));
    this.update(draft => { draft.isLoading = false; }); // Then notify
  };

  // Example of a combined action for creating and closing modal
  async createItemAndCloseModal(newItemData) {
    this.update(draft => {
      draft.isLoading = true;
      // Optimistic update or set loading state
    }, false); // Don't notify yet

    try {
      await new Promise(resolve => setTimeout(resolve, 1000));
      this.update(draft => {
        draft.data.push({ ...newItemData, id: Date.now() });
        draft.isCreateModalOpen = false;
        draft.isLoading = false;
      }); // Now notify once
    } catch (error) {
      this.update(draft => {
        draft.error = error.message;
        draft.isLoading = false;
      }); // Notify on error
    }
  }
}

// Instantiate the store once, outside any React components or hooks
// This provides the stable reference
export const store = new Store();`}
  />

  <p>
    The key to connecting these external, framework-agnostic stores to React's
    rendering system is the <code>useSyncExternalStore</code> hook, introduced in
    React 18. This hook is specifically designed to provide a performant and reliable
    way for React to subscribe to external data sources. It bridges the gap by enabling
    React components to efficiently listen for changes in your independent store.
  </p>

  <p>
    Here's how <code>useSyncExternalStore</code> empowers a more elegant and maintainable
    state management pattern:
  </p>

  <ul>
    <li>
      <strong>Focused Abstraction, Not a New Universe:</strong>
      <code>useSyncExternalStore</code> focuses precisely on its core responsibility:
      syncing React components to external state. It abstracts the "how" of subscription,
      allowing you to concentrate on the "domain you're trying to change, rather
      than its implementation." This avoids the need to pull in an entire new philosophical
      framework just to manage state changes.
    </li>

    <li>
      <strong>Explicit Control Over Rendering:</strong> With an external store, you
      gain a level of control over React's rendering process that is often difficult
      to achieve with hook-based approaches. The store decides <em>exactly</em> when
      to notify its subscribers, which in turn triggers React re-renders via <code
        >useSyncExternalStore</code
      >. This enables powerful optimizations:
      <ul>
        <li>
          <strong>Batching Updates:</strong> You can perform multiple state mutations
          within the store and then trigger a single, consolidated notification to
          subscribers, leading to one efficient React re-render instead of several.
        </li>
        <li>
          <strong>Conditional Re-renders:</strong> The store can implement logic
          to decide whether a state change is significant enough to warrant a UI
          update, preventing unnecessary re-renders for non-visual or intermediate
          state changes.
        </li>
        <li>
          <strong>Synchronized Updates:</strong> By having a single source of truth
          in the external store, you ensure consistent state across all components
          subscribing to it, simplifying complex multi-component interactions.
        </li>
      </ul>
    </li>

    <li>
      <strong>Granular Updates with Selectors:</strong> When used with <a
        href="https://www.npmjs.com/package/use-sync-external-store"
        target="_blank">useSyncExternalStoreWithSelector</a
      >, components can provide a "selector function." This function allows a
      component to subscribe only to the <em>specific parts</em> of the external
      store's state that it truly needs. If other parts of the state change, but
      the selected slice remains the same, the component won't re-render, leading
      to significant performance gains.
      <CodeBlock
        code={`
import { useSyncExternalStore } from 'react';
import { store } from './store'; // Import the singleton store

export function useMyStore() {
  return useSyncExternalStore(
    store.subscribe,
    store.getSnapshot
  );
}

export function useMyStoreSelector(selector) {
  return useSyncExternalStore(
    store.subscribe,
    () => selector(store.getSnapshot())
  );
}`}
      />

      And here's how a component might use these hooks:

      <CodeBlock
        code={`
import React from 'react';
import { useMyStore, useMyStoreSelector } from './hooks';
import { store } from './store'; // Import store for dispatching actions
import { useQuery } from '@tanstack/react-query';

function MyListComponent() {
  // Option 1: Subscribe to the entire store state (will re-render on any change)
  const { data, isLoading, error, searchTerm } = useMyStore();

  // Option 2: Use a selector to subscribe only to specific parts (more performant)
  const isCreateModalOpen = useMyStoreSelector(state => state.isCreateModalOpen);
  const isEditModalOpen = useMyStoreSelector(state => state.isEditModalOpen);

  // Example of integrating with React Query using the store's query options
  const { data: fetchedData, isLoading: queryLoading } = useQuery(
    store.getAllDataQueryOptions('user123')
  );

  return (
    <div class="p-4"></div>
      <h2 class="text-xl font-bold mb-4">My Data List</h2>

      <div class="mb-4"></div>
        <input
          type="text"
          placeholder="Search data..."
          class="p-2 border rounded-md w-full"
          value={searchTerm}
          onChange={(e) => store.setSearchTerm(e.target.value)}
        />
      </div>

      {isLoading || queryLoading ? (
        <p>Loading data...</p>
      ) : error ? (
        <p class="text-red-500">Error: {error}</p>
      ) : (
        <>
          <ul class="list-disc pl-5">
            {(fetchedData || data).map(item => (
              <li key={item.id} class="mb-2"></li>
                {item.title}
              </li>
            ))}
          </ul>
          <button
            onClick={() => store.openCreateModal()}
            class="mt-4 px-4 py-2 bg-blue-500 text-white rounded-md"
          >
            Add New Item
          </button>
        </>
      )}

      {isCreateModalOpen && (
        <div class="fixed inset-0 bg-gray-600 bg-opacity-50 flex justify-center items-center"></div>
          <div class="bg-white p-6 rounded-lg shadow-lg"></div>
            <h3 class="text-lg font-bold mb-4">Create New Item</h3>
            <p>Modal content goes here...</p>
            <button
              onClick={() => store.createItemAndCloseModal({ title: 'New Item' })}
              class="mt-4 px-4 py-2 bg-green-500 text-white rounded-md mr-2"
            >
              Create &amp; Close
            </button>
            <button
              onClick={() => store.closeCreateModal()}
              class="mt-4 px-4 py-2 bg-gray-300 rounded-md"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {isEditModalOpen && (
        <div class="fixed inset-0 bg-gray-600 bg-opacity-50 flex justify-center items-center"></div>
          <div class="bg-white p-6 rounded-lg shadow-lg"></div>
            <h3 class="text-lg font-bold mb-4">Edit Item</h3>
            <p>Edit form goes here...</p>
            <button
              onClick={() => store.closeEditModal()}
              class="mt-4 px-4 py-2 bg-gray-300 rounded-md"
            >
              Close
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

export default MyListComponent;`}
      />
    </li>

    <li>
      <strong>Superior Encapsulation and Testability:</strong> A class-based store
      naturally encapsulates related state and behavior. This makes your application
      logic inherently easier to reason about, maintain, and, crucially, test. Store
      methods are plain JavaScript methods that can be instantiated and tested in
      isolation, without the complexities of mocking React hooks or rendering components
      in a test environment. This clear separation makes UI components much simpler,
      as they primarily become presentational wrappers for the store's data and action
      dispatchers.
      <CodeBlock
        code={`
import { store } from '../store'; // Import the store singleton for testing

describe('Store', () => {
  beforeEach(() => {
    store.state = {
      data: [],
      isLoading: false,
      error: null,
      searchTerm: '',
      // ... other default state properties
    };

    store.subscribers.clear();
    vi.spyOn(store, '_performSearch').mockImplementation(async (term) => {
      console.log('Mocked debounced search for:', term);
      store.update(draft => { draft.isLoading = false; });
    });
  });

  afterEach(() => {
    if (store._performSearch.mockRestore) {
      store._performSearch.mockRestore();
    }
  });

  test('should correctly set search term and trigger debounced search', () => {
    const mockSubscriber = vi.fn();
    store.subscribe(mockSubscriber);

    store.setSearchTerm('test query');

    expect(store.getSnapshot().searchTerm).toBe('test query');
    expect(mockSubscriber).toHaveBeenCalledTimes(1);
    expect(store._performSearch).toHaveBeenCalledWith('test query');
  });

  test('should open and close create modal', () => {
    const mockSubscriber = vi.fn();
    store.subscribe(mockSubscriber);

    expect(store.getSnapshot().isCreateModalOpen).toBe(false);

    store.openCreateModal();
    expect(store.getSnapshot().isCreateModalOpen).toBe(true);
    expect(mockSubscriber).toHaveBeenCalledTimes(1); // One notification for opening

    store.closeCreateModal();
    expect(store.getSnapshot().isCreateModalOpen).toBe(false);
    expect(mockSubscriber).toHaveBeenCalledTimes(2); // Another notification for closing
  });

  test('should update state immutably and notify subscribers', () => {
    const mockSubscriber = vi.fn();
    store.subscribe(mockSubscriber);

    const initialState = store.getSnapshot();
    store.update(draft => {
      draft.isLoading = true;
    });

    const updatedState = store.getSnapshot();
    expect(updatedState.isLoading).toBe(true);
    expect(updatedState).not.toBe(initialState); // Ensure immutability
    expect(mockSubscriber).toHaveBeenCalledTimes(1);
  });

  test('should create item and close modal with single notification', async () => {
    const mockSubscriber = vi.fn();
    store.subscribe(mockSubscriber);

    vi.spyOn(global, 'setTimeout').mockImplementation((cb) => cb());

    await store.createItemAndCloseModal({ id: 99, title: 'New Test Item' });

    expect(store.getSnapshot().isLoading).toBe(false);
    expect(store.getSnapshot().isCreateModalOpen).toBe(false);
    expect(store.getSnapshot().data).toEqual(expect.arrayContaining([{ id: expect.any(Number), title: 'New Test Item' }]));
    expect(mockSubscriber).toHaveBeenCalledTimes(1); // Only one notification after the entire operation
    global.setTimeout.mockRestore(); // Restore original setTimeout
  });
});`}
      />
    </li>

    <li>
      <strong>Reduced React Dependency:</strong> The core business logic residing
      within your external stores becomes fundamentally independent of React. This
      makes your application logic more portable and adaptable, providing long-term
      flexibility should your front-end framework needs evolve.
    </li>

    <li>
      <strong>Seamless Integration with Established Libraries:</strong> This pattern
      doesn't preclude the use of other valuable libraries; rather, it often enhances
      their integration. For example:
      <ul>
        <li>
          You can define methods within your store that return <code
            >React Query</code
          > options, centralizing all data-fetching logic while leveraging <code
            >React Query</code
          >'s robust caching and data synchronization capabilities.
        </li>
        <li>
          Common utilities like <code>lodash</code>'s <code>debounce</code> or <code
            >throttle</code
          > can be directly implemented within store methods for efficient API calls,
          avoiding the need for specialized React debounce hooks.
        </li>
        <li>
          Libraries like <code>Immer</code> can be used within the store's state
          update methods to simplify immutable updates, providing the convenience
          of mutable-looking code with the benefits of immutability.
        </li>
      </ul>
    </li>
  </ul>

  <h2 id="conclusion">Conclusion</h2>

  <p>
    While the pursuit of elegant reactivity is a constant in modern web
    development, it's vital to choose tools and patterns that genuinely
    simplify, rather than obscure. By leveraging the power of independent,
    external stores in conjunction with React's <code>useSyncExternalStore</code
    > hook, developers can craft a state management system that is robust, performant,
    highly testable, and deeply pragmatic. This approach enables a clear separation
    of concerns, keeping complex business logic outside of React's component tree
    until it's ready to be gracefully synced to the UI. Sometimes, the most powerful
    solutions are the ones that respect the nature of the language and focus on the
    problem at hand, rather than imposing an entire new universe.
  </p>
</BlogLayout>
